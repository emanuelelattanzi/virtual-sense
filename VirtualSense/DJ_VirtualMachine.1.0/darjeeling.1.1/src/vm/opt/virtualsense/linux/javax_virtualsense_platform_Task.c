/*
 *	javax_virtualsense_platform_Task.c
 *
 *  Copyright (c) 2012 DiSBeF, University of Urbino.
 *
 *	This file is part of VirtualSense.
 *
 *	VirtualSense is free software: you can redistribute it and/or modify
 *	it under the terms of the GNU General Public License as published by
 *	the Free Software Foundation, either version 3 of the License, or
 *	(at your option) any later version.
 *
 *	VirtualSense is distributed in the hope that it will be useful,
 *	but WITHOUT ANY WARRANTY; without even the implied warranty of
 *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *	GNU General Public License for more details.
 *
 *	You should have received a copy of the GNU General Public License
 *	along with VirtualSense.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * Task (thread) native methods.
 *
 * @author Emanuele Lattanzi
 *
 */


#include <stddef.h>

#include "common/execution/execution.h"
#include "common/global_id.h"
#include "common/debug.h"
#include "common/heap/heap.h"
#include "common/panic.h"

#include "pointerwidth.h"

// generated by the infuser
#include "virtualsense_definitions.h"
#include "base_definitions.h"

//void javax.virtualsense.platform.Task._createTask(short infusionID)
javax_virtualsense_platform_Task_short__createTask_short(){
		dj_infusion *infusion;
		/*dj_di_pointer classDef;
		dj_local_id dj_local_id;
		dj_global_id dj_global_id;*/
		dj_global_id entryPoint;
		int entryPointIndex;

		// pop infusion Id and reference to ExecutionContext
		int16_t infusion_id = dj_exec_stackPopShort();

		DEBUG_LOG("Start loading the new infusion \n");
		// load the corresponding infusion
		infusion = load_external_infusion(infusion_id); //infusion_id should be passed here
		dj_vm_runClassInitialisers(dj_exec_getVM(), infusion);


		DEBUG_LOG("Infusion loaded and initialized at pointer %p and position %d\n", infusion, dj_vm_getInfusionId(dj_exec_getVM(), infusion));
		DEBUG_LOG("INF COUNT %d\n",dj_vm_countInfusions(dj_exec_getVM()));


		// THE INFUSION IS LOADED
		entryPointIndex = dj_di_header_getEntryPoint(infusion->header);
		DEBUG_LOG("Entry point index %d\n",entryPointIndex);

		entryPoint.infusion = infusion;
		entryPoint.entity_id = 1;// should be always 1 !? verify

		// create the top frame for the given method
		dj_frame *frame = dj_frame_create(entryPoint);

		// if we're out of memory, let the caller deal with it
		if (frame==NULL)
		{
			DEBUG_LOG("dj_thread_create_and_run: could not create top frame. Returning null\n");
			return NULL;
		}

		// create a thread to execute the method in
		dj_thread *ret = dj_thread_create();
		ret->executionContext = (uint16_t)infusion_id;

		// if we're out of memory, let the caller deal with it
		if (ret==NULL)
		{
			// free the frame object (if we get here, its allocation was successful)
			DEBUG_LOG("dj_thread_create_and_run: could create the top frame but not the Thread object. Aborting\n");
			dj_mem_free(frame);
			return NULL;
		}

		ret->frameStack = frame;
		dj_vm_addThread(dj_exec_getVM(), ret);
}
// javax.virtualsense.platform.Task._start(short)
void javax_virtualsense_platform_Task_void__start_short()
{

	//TODO: find thread by the infusion ID now it is progressive.
	// pop thread Id and get the corresponding Thread object
	int16_t id = dj_exec_stackPopShort();
	dj_thread * thread = dj_vm_getThreadByExecutionContext(dj_exec_getVM(), id);
	// mark new thread eligible for execution
	thread->status = THREADSTATUS_RUNNING;
	thread->need_resched = 1;

}
