/*
 *	javax_virtualsense_platform_Task.c
 *
 *  Copyright (c) 2013 DiSBeF, University of Urbino.
 *
 *	This file is part of VirtualSense.
 *
 *	VirtualSense is free software: you can redistribute it and/or modify
 *	it under the terms of the GNU General Public License as published by
 *	the Free Software Foundation, either version 3 of the License, or
 *	(at your option) any later version.
 *
 *	VirtualSense is distributed in the hope that it will be useful,
 *	but WITHOUT ANY WARRANTY; without even the implied warranty of
 *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *	GNU General Public License for more details.
 *
 *	You should have received a copy of the GNU General Public License
 *	along with VirtualSense.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * Task (thread) native methods.
 *
 * @author Emanuele Lattanzi
 *
 */


#include <stddef.h>

#include "common/execution/execution.h"
#include "common/global_id.h"
#include "common/debug.h"
#include "common/heap/heap.h"
#include "common/panic.h"
#include "common/app_manager.h"


#include "pointerwidth.h"

// generated by the infuser
#include "virtualsense_definitions.h"
#include "base_definitions.h"
//#define DEBUG_LOG(format, args...)
// initializing methods for tasks found on the task table at startup or reboot.

javax_virtualsense_platform_Task_short__getDefaultTasksNumber(){
	char * tb;
	uint16_t i;
	tb = app_manager_getApplicationTable();
	int16_t number = 0;

	struct virtualsense_execution_context *context;
	for(i = 0; i < TABLE_ENTRIES*ENTRY_SIZE; i+=ENTRY_SIZE){
	  context = (struct virtualsense_execution_context *)(tb+i);
	  if(context->execution_context_id > 0)
		  number++;
	}
	DEBUG_LOG("Installed applications %d\n",number);
	dj_exec_stackPushShort(number);
}


javax_virtualsense_platform_Task_short__getDefaultExecutionContextID_short(){
	char * tb;

	tb = app_manager_getApplicationTable();
	int16_t executionContextID = 0;
	uint16_t i = dj_exec_stackPopShort();

	struct virtualsense_execution_context *context;
	context = (struct virtualsense_execution_context *)(tb+(i*ENTRY_SIZE));
	executionContextID = context->execution_context_id;
	dj_exec_stackPushShort(executionContextID);

}
javax_virtualsense_platform_Task_boolean__defaultNeedToLoad_short(){
	char * tb;
	tb = app_manager_getApplicationTable();
	int16_t toLoad = 0;
	uint16_t i = dj_exec_stackPopShort();

	struct virtualsense_execution_context *context;
	context = (struct virtualsense_execution_context *)(tb+(i*ENTRY_SIZE));
	toLoad = (int16_t)context->loaded;
	DEBUG_LOG("To load is %d\n",toLoad);
	dj_exec_stackPushShort(toLoad);

}
javax_virtualsense_platform_Task_boolean__defaultNeedToStart_short(){
	char * tb;
	tb = app_manager_getApplicationTable();
	int16_t toStart = 0;
	uint16_t i = dj_exec_stackPopShort();

	struct virtualsense_execution_context *context;
	context = (struct virtualsense_execution_context *)(tb+(i*ENTRY_SIZE));
	toStart = (int16_t)context->running;
	DEBUG_LOG("To start is %d\n",toStart);
	dj_exec_stackPushShort(toStart);
}



javax_virtualsense_platform_Task_short__loadExecutionContext_short(){
	dj_infusion *infusion;
	dj_di_pointer app_pointer;
	unsigned long int rr = 0;
	// pop executionContextID
	int16_t executionContext_id = dj_exec_stackPopShort();
	int16_t infusion_id = -1;

	/*if(app_manager_isLoaded(executionContext_id)){
		printf("ExecutionContext already loaded aborting operation \n"); // TODO: raise exception
		dj_exec_stackPushShort(infusion_id);
		return;
	}*/
	DEBUG_LOG("Start loading the new infusion \n");
	// load the corresponding infusion

	app_pointer = app_manager_getDiFilePointer(executionContext_id);
	DEBUG_LOG("Found a pointer to the app at %x\n", app_pointer);
	if(app_pointer == 0) {
		printf("ExecutionContext not found \n"); // TODO: raise exception
		dj_exec_stackPushShort(infusion_id);
		return;
	}
	infusion = dj_vm_loadInfusion(dj_exec_getVM(), app_pointer);
	//HERE a deferred initialization is needed otherwise the calling thread
	// is deactivated causing the execution jup to this method invocation
	// causing a loop.
	dj_main_runDeferredInitializer(infusion);

	DEBUG_LOG("Infusion loaded and initialized at pointer %p and position %d\n", infusion, dj_vm_getInfusionId(dj_exec_getVM(), infusion));
	DEBUG_LOG("INF COUNT %d\n",dj_vm_countInfusions(dj_exec_getVM()));
	infusion_id = (int16_t)dj_vm_getInfusionId(dj_exec_getVM(), infusion);
	DEBUG_LOG("Pushing infusion id %d\n", infusion_id);
	dj_exec_stackPushShort(infusion_id);
	DEBUG_LOG("Infusion pushed  onto the stack\n");
}


// javax.virtualsense.platform.Task._start(short)
void javax_virtualsense_platform_Task_void__start_short_short()
{
		int entryPointIndex;
		dj_infusion *infusion;
		dj_global_id entryPoint;


		// pop executionContextID
		int16_t execution_context_id = dj_exec_stackPopShort();
		// pop infusionID
		int16_t infusion_id = dj_exec_stackPopShort();

		/*if(app_manager_isRunning(execution_context_id)){
			printf("ExecutionContext already running aborting operation \n"); // TODO: raise exception
			return;
		}*/
		//printf("Infusion id popped  %d\n", infusion_id);
		DEBUG_LOG("Execution context  id popped  %d\n", execution_context_id);
		infusion = dj_vm_getInfusion(dj_exec_getVM(), infusion_id);
		DEBUG_LOG("Infusion pointer %p\n", infusion);

		entryPointIndex = dj_di_header_getEntryPoint(infusion->header);
		DEBUG_LOG("Entry point index %d\n",entryPointIndex);

		entryPoint.infusion = infusion;
		entryPoint.entity_id = entryPointIndex;

		// create the top frame for the given method
		dj_frame *frame = dj_frame_create(entryPoint);

		// if we're out of memory, let the caller deal with it
		if (frame==NULL)
		{
			DEBUG_LOG("START: could not create top frame.\n");
			return NULL;
		}

		// create a thread to execute the method in
		dj_thread *ret = dj_thread_create();
		ret->executionContext = (uint16_t)execution_context_id;

		// if we're out of memory, let the caller deal with it
		if (ret==NULL)
		{
			// free the frame object (if we get here, its allocation was successful)
			DEBUG_LOG("dj_thread_create_and_run: could create the top frame but not the Thread object. Aborting\n");
			dj_mem_free(frame);
			return NULL;
		}

		ret->frameStack = frame;
		DEBUG_LOG("START: adding a thread .\n");
		dj_vm_addThread(dj_exec_getVM(), ret);
		// mark new thread eligible for execution
		ret->status = THREADSTATUS_RUNNING;
		ret->need_resched = 1;
		DEBUG_LOG("START: thread ready to run.\n");

}


void javax_virtualsense_platform_Task_void__stop_short()
{
	dj_thread * thread;
	dj_frame * frame;
	dj_infusion * unloadInfusion;

	int16_t infusion_id = dj_exec_stackPopShort();
	dj_vm * vm = dj_exec_getVM();
	unloadInfusion = dj_vm_getInfusion(vm, infusion_id);

	// kill any thread that is currently executing any method in the infusion that we're unloading
	thread = vm->threads;
	while (thread!=NULL)
	{

		// check each frame
		frame = thread->frameStack;
		while (frame!=NULL)
		{
			if (frame->method.infusion==unloadInfusion)
			{
				// kill the thread
				thread->status = THREADSTATUS_FINISHED;

				break;
			}
			frame = frame->parent;
		}

		// next thread
		thread = thread->next;
	}
}
