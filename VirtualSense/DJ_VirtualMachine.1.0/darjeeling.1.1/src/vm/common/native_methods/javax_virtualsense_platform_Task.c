/*
 *	javax_virtualsense_platform_Task.c
 *
 *  Copyright (c) 2012 DiSBeF, University of Urbino.
 *
 *	This file is part of VirtualSense.
 *
 *	VirtualSense is free software: you can redistribute it and/or modify
 *	it under the terms of the GNU General Public License as published by
 *	the Free Software Foundation, either version 3 of the License, or
 *	(at your option) any later version.
 *
 *	VirtualSense is distributed in the hope that it will be useful,
 *	but WITHOUT ANY WARRANTY; without even the implied warranty of
 *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *	GNU General Public License for more details.
 *
 *	You should have received a copy of the GNU General Public License
 *	along with VirtualSense.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * Task (thread) native methods.
 *
 * @author Emanuele Lattanzi
 *
 */


#include <stddef.h>

#include "common/execution/execution.h"
#include "common/global_id.h"
#include "common/debug.h"
#include "common/heap/heap.h"
#include "common/panic.h"
#include "common/app_manager.h"


#include "pointerwidth.h"

// generated by the infuser
#include "virtualsense_definitions.h"
#include "base_definitions.h"


javax_virtualsense_platform_Task_short__loadExecutionContext_short(){
	dj_infusion *infusion;
	dj_di_pointer app_pointer;
	unsigned long int rr = 0;
	// pop executionContextID
	int16_t executionContext_id = dj_exec_stackPopShort();
	int16_t infusion_id = -1;

	DEBUG_LOG("Start loading the new infusion \n");
	// load the corresponding infusion

	app_pointer = app_manager_getDiFilePointer(executionContext_id);
	//printf("Found a pointer to the app at %x\n", app_pointer);
	if(app_pointer == 0) {
		printf("ExecutionContext not found \n"); // TODO: raise exception
	} else {
		infusion = dj_vm_loadInfusion(dj_exec_getVM(), app_pointer);
		//HERE a deferred initialization is needed otherwise the calling thread
		// is deactivated causing the execution jup to this method invocation
		// causing a loop.
		dj_main_runDeferredInitializer(infusion);
		//dj_vm_runClassInitialisers(dj_exec_getVM(), infusion);


		DEBUG_LOG("Infusion loaded and initialized at pointer %p and position %d\n", infusion, dj_vm_getInfusionId(dj_exec_getVM(), infusion));
		DEBUG_LOG("INF COUNT %d\n",dj_vm_countInfusions(dj_exec_getVM()));
		infusion_id = (int16_t)dj_vm_getInfusionId(dj_exec_getVM(), infusion);
		DEBUG_LOG("Popping infusion id %d\n", infusion_id);
	}
	dj_exec_stackPushShort(infusion_id);
}


// javax.virtualsense.platform.Task._start(short)
void javax_virtualsense_platform_Task_void__start_short_short()
{
		int entryPointIndex;
		dj_infusion *infusion;
		dj_global_id entryPoint;


		// pop executionContextID
		int16_t execution_context_id = dj_exec_stackPopShort();
		// pop infusionID
		int16_t infusion_id = dj_exec_stackPopShort();
		printf("Infusion id popped  %d\n", infusion_id);
		DEBUG_LOG("Execution context  id popped  %d\n", execution_context_id);
		infusion = dj_vm_getInfusion(dj_exec_getVM(), infusion_id);
		DEBUG_LOG("Infusion pointer %p\n", infusion);

		entryPointIndex = dj_di_header_getEntryPoint(infusion->header);
		DEBUG_LOG("Entry point index %d\n",entryPointIndex);

		entryPoint.infusion = infusion;
		entryPoint.entity_id = entryPointIndex;

		// create the top frame for the given method
		dj_frame *frame = dj_frame_create(entryPoint);

		// if we're out of memory, let the caller deal with it
		if (frame==NULL)
		{
			printf("dj_thread_create_and_run: could not create top frame. Returning null\n");
			return NULL;
		}

		// create a thread to execute the method in
		dj_thread *ret = dj_thread_create();
		ret->executionContext = (uint16_t)execution_context_id;

		// if we're out of memory, let the caller deal with it
		if (ret==NULL)
		{
			// free the frame object (if we get here, its allocation was successful)
			DEBUG_LOG("dj_thread_create_and_run: could create the top frame but not the Thread object. Aborting\n");
			dj_mem_free(frame);
			return NULL;
		}

		ret->frameStack = frame;
		dj_vm_addThread(dj_exec_getVM(), ret);
		// mark new thread eligible for execution
		ret->status = THREADSTATUS_RUNNING;
		ret->need_resched = 1;

}


void javax_virtualsense_platform_Task_void__stop_short()
{
	dj_thread * thread;
	dj_frame * frame;
	dj_infusion * unloadInfusion;

	int16_t infusion_id = dj_exec_stackPopShort();
	dj_vm * vm = dj_exec_getVM();
	unloadInfusion = dj_vm_getInfusion(vm, infusion_id);

	// kill any thread that is currently executing any method in the infusion that we're unloading
	thread = vm->threads;
	while (thread!=NULL)
	{

		// check each frame
		frame = thread->frameStack;
		while (frame!=NULL)
		{
			if (frame->method.infusion==unloadInfusion)
			{
				// kill the thread
				thread->status = THREADSTATUS_FINISHED;

				break;
			}
			frame = frame->parent;
		}

		// next thread
		thread = thread->next;
	}
}

